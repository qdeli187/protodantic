{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83d\ude80 Protodantic","text":"<p>Bridge the gap between Protocol Buffers and Pydantic validation.</p> <p>Protodantic is a Python library that seamlessly integrates Protocol Buffers with Pydantic, giving you the best of both worlds: powerful data validation and efficient binary serialization.</p>"},{"location":"#project-goal","title":"\ud83c\udfaf Project Goal","text":"<p>Protodantic enables developers to:</p> <ul> <li>Use Pydantic models with proto files seamlessly</li> <li>Leverage Pydantic's robust validation framework</li> <li>Serialize and deserialize with zero configuration</li> </ul> <p>Whether you're building microservices, APIs, or distributed systems, Protodantic makes it easy to work with validated, serializable data structures.</p>"},{"location":"#end-goal","title":"End Goal","text":"<p>The end goal of this library is to be a plugin for protobuf compilers like grpcio-tools. Instead of generation protobuf message classes you would generate ProtoModels.</p>"},{"location":"#but-why-though","title":"But why Though ?","text":"<p>This Project emerged from a frustration while building an OPAMP server for opentelemetry agents with Fastapi. Pydantic and protobuf don't bode well together but it's a shame because pydantic can be used for Fastapi but only (sqlmodel for ORM , faststream for EDS and so on...)</p> <p>Info</p> <p>I believe this library will be useful for developers building apps with both protobuf and the pydantic ecosystem (Fastapi, SqlModel, FastStream ...)</p> <p>But it can also be useful without proto files altogether , protobuf's encoding is more efficient than json. Two codebases sharing the same Protomodels can exchange data more efficiently</p>"},{"location":"#currently-supported-features","title":"\u2728 Currently Supported Features","text":""},{"location":"#core-types","title":"Core Types","text":"<ul> <li>\u2705 Primitive Types - <code>int</code>, <code>str</code>, <code>float</code>, <code>bool</code>, <code>bytes</code></li> <li>\u2705 Optional Fields - <code>Optional[T]</code> and union types</li> <li>\u2705 Boolean &amp; Numeric - Full support for integers, floats, and booleans</li> </ul>"},{"location":"#advanced-structures","title":"Advanced Structures","text":"<ul> <li>\u2705 Nested Messages - Complex hierarchical data models</li> <li>\u2705 Lists / Repeated Fields - <code>list[T]</code> for repeated elements</li> <li>\u2705 Enumerations - Type-safe enums with automatic validation</li> <li>\u2705 Custom Validators - Full Pydantic validation support</li> </ul>"},{"location":"#serialization","title":"Serialization","text":"<ul> <li>\u2705 Protocol Buffer Encoding - <code>model_dump_proto()</code> method</li> <li>\u2705 Protocol Buffer Decoding - <code>model_validate_proto()</code> method</li> <li>\u2705 Pydantic Integration - Use all Pydantic features alongside protobuf</li> </ul>"},{"location":"#validation","title":"Validation","text":"<ul> <li>\u2705 Type Checking - Automatic type validation on instantiation</li> <li>\u2705 Required/Optional - Clear nullable/required field semantics</li> <li>\u2705 Custom Rules - Support for Pydantic validators and field constraints</li> <li>\u2705 Nested Validation - Recursive validation of nested structures</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<pre><code>from protodantic import ProtoModel\n\nclass Person(ProtoModel):\n    name: str\n    age: int\n    email: str\n\n# Create an instance\nperson = Person(name=\"Alice\", age=30, email=\"alice@example.com\")\n\n# Serialize to Protocol Buffer bytes\nencoded = person.model_dump_proto()\n\n# Deserialize back\ndecoded = Person.model_validate_proto(encoded)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thanks for visiting this page ! We are thankful for your consideration !</p> <p>Contibuting does not necessarly means coding</p> <p>Indeed , taking the time to fill in a detailed issue for a bug or feature or proposing updates to the docs are also incredible ways you can support this project !</p>"},{"location":"contributing/#contribution-workflow","title":"\u2728 Contribution Workflow","text":"<ol> <li>I create a detailed issue on a bug or a feature request and kindly propose my help</li> <li>I fork the repo and create a branch to work on</li> <li>I code and update / add unit tests</li> <li>I run all unit tests</li> <li>I merge my change back into the main repo with a Pull Request</li> <li>I link the issues in the PR</li> <li>your work will be reviewed and hopefully merged with all the thanks of the community</li> </ol>"},{"location":"contributing/#setup","title":"\ud83d\udeeb Setup","text":"<pre><code># create a venv\npython -m venv .venv\n# activate it\nsource .venv/bin/activate\n# install dependencies ('pipx install poetry' if need be)\npoetry install\n</code></pre>"},{"location":"contributing/#testing","title":"\ud83e\uddea Testing","text":"<p>Run the test suite:</p> <pre><code>pytest tests/\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome! This hands-on guide will walk you through the core concepts of Protodantic using practical examples. We'll cover basic usage, lists (repeated fields), nested messages, and enums.</p>"},{"location":"getting-started/#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install protodantic\n</code></pre>"},{"location":"getting-started/#basic-example","title":"\ud83d\udd30 Basic Example","text":"<p>Let's start with a simple example. Create a basic Pydantic model and extend it with Protodantic's <code>ProtoModel</code>:</p> <pre><code>from protodantic import ProtoModel\n\nclass Person(ProtoModel):\n    name: str\n    age: int\n    email: str\n\n# Create an instance\nperson = Person(name=\"Alice\", age=30, email=\"alice@example.com\")\n\nprint(person)\n# Output: name='Alice' age=30 email='alice@example.com'\n\n# Serialize to Protocol Buffer bytes\nencoded = person.model_dump_proto()\nprint(encoded)\n# Output: b'\\n\\x05Alice\\x10\\x1e\\x1a\\x12alice@example.com'\n\n# Deserialize back\ndecoded = Person.model_validate_proto(encoded)\nprint(decoded)\n# Output: name='Alice' age=30 email='alice@example.com'\nassert decoded == person\n</code></pre> <p>That's it! You now have automatic Protocol Buffer serialization with full Pydantic validation.</p>"},{"location":"getting-started/#working-with-lists-repeated-fields","title":"\ud83d\udccb Working with Lists (Repeated Fields)","text":"<p>Protodantic makes it easy to work with repeated fields (lists). Use Python's <code>list</code> type annotation:</p> <pre><code>from protodantic import ProtoModel\nfrom typing import List\n\nclass Person(ProtoModel):\n    name: str\n    hobbies: list[str]\n\n# Create an instance with a list\nperson = Person(\n    name=\"Bob\",\n    hobbies=[\"reading\", \"gaming\", \"coding\"]\n)\n\nprint(person.hobbies)\n# Output: ['reading', 'gaming', 'coding']\n\n# Serialize and deserialize\nencoded = person.model_dump_proto()\ndecoded = Person.model_validate_proto(encoded)\n\nprint(decoded.hobbies)\n# Output: ['reading', 'gaming', 'coding']\n\nassert decoded == person\n</code></pre>"},{"location":"getting-started/#key-points-about-lists","title":"Key Points about Lists:","text":"<ul> <li>Type Annotation: Use <code>list[T]</code> to define repeated fields (works with any supported type)</li> <li>Validation: Pydantic validates that the field is actually a list</li> <li>Empty Lists: Empty lists are allowed by default</li> <li>Any Type: Lists can contain primitives, bytes, nested messages, or enums</li> <li>Multiple Items: Each item is encoded as a separate protobuf message field</li> </ul> <p>Example with multiple item types:</p> <pre><code>class Contact(ProtoModel):\n    name: str\n    phone_numbers: list[str]\n    email_addresses: list[str]\n    tags: list[int]\n\ncontact = Contact(\n    name=\"Alice\",\n    phone_numbers=[\"+1-555-0100\", \"+1-555-0101\"],\n    email_addresses=[\"alice@example.com\", \"alice.work@example.com\"],\n    tags=[1, 2, 3, 4, 5]\n)\n\nprint(contact.phone_numbers)\n# Output: ['+1-555-0100', '+1-555-0101']\n\n# Serialize\nencoded = contact.model_dump_proto()\n\n# Deserialize\ndecoded = Contact.model_validate_proto(encoded)\nassert decoded == contact\n</code></pre>"},{"location":"getting-started/#working-with-enums","title":"\ud83c\udfa8 Working with Enums","text":"<p>Enums provide type-safe enumeration values. Define them using Python's <code>IntEnum</code>:</p> <pre><code>from enum import IntEnum\nfrom protodantic import ProtoModel\n\nclass Status(IntEnum):\n    UNKNOWN = 0\n    ACTIVE = 1\n    INACTIVE = 2\n    PENDING = 3\n\nclass User(ProtoModel):\n    username: str\n    status: Status\n\n# Create an instance with an enum\nuser = User(username=\"bob\", status=Status.ACTIVE)\n\nprint(user.status)\n# Output: &lt;Status.ACTIVE: 1&gt;\n\nprint(user.status.value)\n# Output: 1\n\n# Serialize and deserialize\nencoded = user.model_dump_proto()\ndecoded = User.model_validate_proto(encoded)\n\nprint(decoded.status)\n# Output: &lt;Status.ACTIVE: 1&gt;\n\nassert decoded == user\n</code></pre> <p>Enums in Protobuf</p> <p>Protobuf established that the first value of an enum is always the default value. It is recommended to always set the first value of an Enum to TYPE_UNKNOWN or TYPE_UNSET</p>"},{"location":"getting-started/#key-points-about-enums","title":"Key Points about Enums:","text":"<ul> <li>Type Safety: Enums ensure only valid values are accepted</li> <li>Validation: Pydantic validates enum values automatically</li> <li>Integer Values: Enums are serialized as their integer values in protobuf</li> <li>Deserialization: When deserializing, the integer is converted back to the enum</li> <li>Error Handling: Invalid enum values raise a validation error</li> </ul> <p>Example with enum validation:</p> <pre><code># This will raise a validation error\ntry:\n    invalid_user = User(username=\"bob\", status=\"INVALID_STATUS\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n    # The status field must be a valid Status enum value\n\n# Correct usage\nuser = User(username=\"bob\", status=Status.ACTIVE)  # \u2713\n</code></pre>"},{"location":"getting-started/#nested-messages","title":"\ud83c\udfd7\ufe0f Nested Messages","text":"<p>Nested messages allow you to create complex, hierarchical data structures:</p> <pre><code>from protodantic import ProtoModel\n\nclass Address(ProtoModel):\n    street: str\n    city: str\n    zipcode: str\n\nclass Contact(ProtoModel):\n    id: bytes\n    type: str\n    value: str\n\nclass Person(ProtoModel):\n    name: str\n    age: int\n    email: str\n    address: Address\n    contacts: list[Contact]\n\n# Create an instance with nested data\nperson = Person(\n    name=\"John Doe\",\n    age=30,\n    email=\"john@example.com\",\n    address=Address(\n        street=\"123 Main St\",\n        city=\"Anytown\",\n        zipcode=\"12345\"\n    ),\n    contacts=[\n        Contact(id=b'\\x01', type=\"phone\", value=\"555-0100\"),\n        Contact(id=b'\\x02', type=\"email\", value=\"john@work.com\")\n    ]\n)\n\nprint(person.address.city)\n# Output: 'Anytown'\n\nprint(person.contacts[0].value)\n# Output: '555-0100'\n\n# Serialize and deserialize\nencoded = person.model_dump_proto()\ndecoded = Person.model_validate_proto(encoded)\n\nprint(decoded.address.city)\n# Output: 'Anytown'\n\nprint(len(decoded.contacts))\n# Output: 2\n\nassert decoded == person\n</code></pre>"},{"location":"getting-started/#key-points-about-nested-messages","title":"Key Points about Nested Messages:","text":"<ul> <li>Definition: Nested models are defined as class attributes with type annotations</li> <li>Access: Access nested fields using dot notation (<code>person.address.city</code>)</li> <li>Validation: Pydantic validates nested structures recursively</li> <li>Serialization: Nested messages are automatically encoded as length-delimited protobuf messages</li> <li>Deserialization: Nested structures are properly reconstructed from bytes</li> <li>Deep Nesting: Nested messages can themselves contain nested messages</li> </ul> <p>Example with multiple levels of nesting:</p> <pre><code>class Country(ProtoModel):\n    name: str\n    code: str\n\nclass City(ProtoModel):\n    name: str\n    country: Country\n\nclass Address(ProtoModel):\n    street: str\n    city: City\n\nclass Person(ProtoModel):\n    name: str\n    address: Address\n\n# Create deeply nested data\nperson = Person(\n    name=\"Alice\",\n    address=Address(\n        street=\"123 Main St\",\n        city=City(\n            name=\"San Francisco\",\n            country=Country(name=\"USA\", code=\"US\")\n        )\n    )\n)\n\n# Access deeply nested fields\nprint(person.address.city.country.code)\n# Output: 'US'\n\n# Works seamlessly with serialization\nencoded = person.model_dump_proto()\ndecoded = Person.model_validate_proto(encoded)\nassert decoded == person\n</code></pre>"},{"location":"getting-started/#complete-example-combining-everything","title":"\ud83d\udd17 Complete Example: Combining Everything","text":"<p>Let's create a real-world example using lists, nested messages, enums, and optional fields together:</p> <pre><code>from protodantic import ProtoModel\nfrom enum import IntEnum\nfrom typing import Optional\n\nclass Priority(IntEnum):\n    LOW = 0\n    MEDIUM = 1\n    HIGH = 2\n\nclass Tag(ProtoModel):\n    name: str\n    color: str\n\nclass Task(ProtoModel):\n    title: str\n    description: str\n    priority: Priority\n    tags: list[Tag]\n    assigned_to: Optional[str] = None\n\nclass Project(ProtoModel):\n    name: str\n    tasks: list[Task]\n\n# Create a complete project structure\nproject = Project(\n    name=\"Website Redesign\",\n    tasks=[\n        Task(\n            title=\"Design mockups\",\n            description=\"Create UI mockups\",\n            priority=Priority.HIGH,\n            tags=[\n                Tag(name=\"design\", color=\"#FF5733\"),\n                Tag(name=\"urgent\", color=\"#FF0000\")\n            ],\n            assigned_to=\"alice\"\n        ),\n        Task(\n            title=\"Implement frontend\",\n            description=\"Build components\",\n            priority=Priority.MEDIUM,\n            tags=[\n                Tag(name=\"frontend\", color=\"#0066CC\")\n            ]\n        ),\n        Task(\n            title=\"Write documentation\",\n            description=\"Document the API\",\n            priority=Priority.LOW,\n            tags=[],\n            assigned_to=None  # Optional field\n        )\n    ]\n)\n\n# Access nested data\nprint(f\"Project: {project.name}\")\nprint(f\"First task priority: {project.tasks[0].priority}\")  # Priority.HIGH\nprint(f\"Second task tags: {project.tasks[1].tags}\")\nprint(f\"Third task assigned to: {project.tasks[2].assigned_to}\")  # None\n\n# Serialize\nencoded = project.model_dump_proto()\nprint(f\"Serialized size: {len(encoded)} bytes\")\n\n# Deserialize\ndecoded = Project.model_validate_proto(encoded)\nassert decoded == project\n\nprint(\"\u2713 Serialization and deserialization successful!\")\n</code></pre>"},{"location":"getting-started/#serialization-and-deserialization","title":"\ud83d\udd04 Serialization and Deserialization","text":""},{"location":"getting-started/#encoding-to-protocol-buffers","title":"Encoding to Protocol Buffers","text":"<pre><code>from protodantic import ProtoModel\n\nclass Person(ProtoModel):\n    name: str\n    age: int\n\nperson = Person(name=\"Alice\", age=30)\n\n# Encode to protobuf bytes\nencoded = person.model_dump_proto()\nprint(type(encoded))  # &lt;class 'bytes'&gt;\nprint(encoded)        # b'\\n\\x05Alice\\x10\\x1e'\n</code></pre>"},{"location":"getting-started/#decoding-from-protocol-buffers","title":"Decoding from Protocol Buffers","text":"<pre><code># Decode from bytes\ndecoded = Person.model_validate_proto(encoded)\nprint(decoded)  # name='Alice' age=30\nassert decoded == person\n</code></pre>"},{"location":"getting-started/#working-with-files","title":"Working with Files","text":"<pre><code># Save to file\nwith open(\"person.pb\", \"wb\") as f:\n    f.write(encoded)\n\n# Load from file\nwith open(\"person.pb\", \"rb\") as f:\n    data = f.read()\n\ndecoded = Person.model_validate_proto(data)\n</code></pre>"},{"location":"getting-started/#validation-and-error-handling","title":"\u2705 Validation and Error Handling","text":"<p>Pydantic automatically validates your data when creating instances:</p> <pre><code>from protodantic import ProtoModel\nfrom enum import IntEnum\n\nclass Status(IntEnum):\n    ACTIVE = 1\n    INACTIVE = 0\n\nclass User(ProtoModel):\n    name: str\n    age: int\n    status: Status\n\n# Type validation\ntry:\n    user = User(name=\"Bob\", age=\"thirty\", status=Status.ACTIVE)\nexcept ValueError as e:\n    print(f\"Error: Invalid age type\")\n\n# Enum validation\ntry:\n    user = User(name=\"Bob\", age=30, status=\"INVALID\")\nexcept ValueError as e:\n    print(f\"Error: Invalid status enum value\")\n\n# Successful creation\nuser = User(name=\"Bob\", age=30, status=Status.ACTIVE)  # \u2713\nprint(user)\n</code></pre> <p>Happy coding with Protodantic! \ud83d\ude80</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Here is the roadmap for this project. We are open to make changes based on community suggestions</p>"},{"location":"roadmap/#items","title":"Items","text":"<ul> <li> Basic scalar types (<code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code>, <code>bytes</code>)</li> <li> Nested messages (ProtoModel instances)</li> <li> Repeated fields (lists)</li> <li> Optional fields (Union with None)</li> <li> Automatic field numbering (1-indexed based on field order)</li> <li> Round-trip serialization/deserialization</li> <li> Full Pydantic validation support</li> <li> Enum Support: Handle Python enums and protobuf enum types</li> <li> Additional Scalar Types: <code>int32</code>, <code>int64</code>, <code>uint32</code>, <code>uint64</code>, <code>sint32</code>, <code>sint64</code>, <code>fixed32</code>, <code>fixed64</code>, <code>sfixed32</code>, <code>sfixed64</code>, <code>double</code> precision support</li> <li> Oneof Fields: Support for protobuf's <code>oneof</code> pattern (mutually exclusive fields)</li> <li> Map Types: Handle <code>dict</code> types as protobuf map fields</li> <li> Field Number Configuration: Allow explicit field number specification via Pydantic Field metadata</li> <li> Circular Reference Handling: Better support for self-referencing and circular model dependencies</li> <li> Packed Encoding: Automatic packed encoding for repeated scalar fields</li> <li> Protoc plugin for this lib: Generate pydantic classes from <code>.proto</code> files</li> <li> Default Values: Proper handling of protobuf default values (current naive approach does work though)</li> <li> Unknown Field Handling: Gracefully handle fields in the binary data that don't exist in the model</li> <li> Streaming Support: Large message serialization/deserialization with streaming</li> </ul>"},{"location":"roadmap/#milestones","title":"Milestones","text":"<ul> <li> Support for all protobuf types and field indexes</li> <li> protoc plugin</li> <li> Rust encoding and decoding , similar to pydantic</li> <li> Proposing to merge these features onto pydantic (who knows \ud83d\udcaa ?!)</li> </ul>"}]}